* Fixes

CC backend: goto (needs test), 
sort with non-default comparison. 
last for non-loop blocks (needs simplier test, test 29).
improve XSUB handling (both static and dynamic, needs tests)
sv_magic can do SvREFCNT_inc(obj) which messes up precalculated refcounts
allocation of XPV[INAHC]V structures needs fixing: Perl tries to free
  them, whereas the compiler expects them to be linked to a xpv[inahc]v_root
list the same as X[IPR]V structures.
ref counts
perl_parse replacement
compile-time initialisation of AvARRAYs (improved with -fav-init)
signed/unsigned problems with NV (and IV?) initialisation and elsewhere?
CvOUTSIDE for ordinary subs
DATA filehandle for C-compiled program (almost done)
pv_copy_on_grow no &PL_SV_undef in static inits

* Features

type checking: Devel::TypeCheck
compile time v. runtime initialisation:
  execute run-time BEGIN blocks for side-effects such as print or chdir, 
  use and require not.
save PMOPs in compiled form
selection of what to dump
options for cutting out line info (COP elimination) etc. (-fcop)
shared constants (share_hek, constpv)
check module dependencies, vs. link libs static, not via DynaLoader
new Asm, JIT or PIR backend, PLJC ByteLoader magic
check Bytecode op coverage in the tests, should cover all ops 0-142
ByteLoader compatibility: version, platform. eventually Bytecode version 
  portability (test with 5.6 on cygwin, partially done)

* Optimisations

fix optimize_ppaddr for B::CC 
collect static strings beforehand, such as GvNAMEs, COP FILENAME (for pre 5.10)
  and GV method names package::name. (partially done)
proper static init of PMOP SV's (only works dynamic >= 5.10)
proper static init of PVBM/FBM (almost done, just 5.8.9 not)
collapse LISTOPs to UNOPs or BASEOPs
compile-time qw(), constant subs
global analysis of variables, type hints etc.
  understand type attrs 
    my $i : Ci32;
  Devel::TypeCheck instead of magic variable _ir, ... suffices
  e.g. mark IVonly SV's and magic/flags change functions and 
  optimize all op subtrees for the compiled backends to use direct ints
demand-loaded bytecode (leader of each basic block replaced by an op
  which loads in bytecode for its block)
fast sub calls for CC backend
tailcall optimization (entersub -> leavesub => goto)
bind runops with leaner PERL_ASYNC_CHECK only when meaningful.
  Hmm, B::CC already unrolls the ops and does no PERL_ASYNC_CHECK at all.

  /* B::C */ 
  while ((PL_op = CALL_FPTR(PL_op->op_ppaddr)(aTHX))) {
    PERL_ASYNC_CHECK();
  }
  =>
  /* B::CC */
  EXTEND(sp, 1);
  PUSHs((SV*)&sv_list[2]);
  PL_op = (OP*)&listop_list[0];
  DOOP(PL_ppaddr[OP_PRINT]);

  cSVOP_sv = &sv_list[0];
  PUSHs((SV*)&sv_list[2]);
  PL_stack_sp = sp; PL_op = PL_ppaddr[OP_CONST](); PL_stack_sp = sp;
  PL_op = (OP*)&listop_list[0]; /*PRINT*/
  ..
  =>
  /* -MO=CC,-O3,-fbind-ppaddr */
  EXTEND(sp, 1);
  PUSHs((SV*)&sv_list[2]);
  PL_op = (OP*)&listop_list[0];
  PL_stack_sp=sp; PL_op = pp_print(); PL_stack_sp=sp;;
  =>
  /* -fdynamic-runops. patch PL_op members at run-time.
     same data and stack handling, but no optree structure in memory */
  cSVOP_sv = &sv_list[0];
  PL_op = pp_const();
  PL_op->op_private = OPpLVAL_INTRO;
  cGVOP_gv = &gv_list[0];
  PL_op = pp_gvsv();
  EXTEND(sp, 1);
  PUSHs((SV*)&sv_list[2]);
  PL_stack_sp = sp; PL_op = pp_print(); PL_stack_sp = sp;
  PERL_ASYNC_CHECK;
