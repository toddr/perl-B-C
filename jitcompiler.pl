# Copyright (c) 2008 Reini Urban

=pod

=head1 JIT or ASM?

Two possible native code attempts:

1. Use B<GNU lightning> to compile to jit at eval-time, and
   jitrun the whole codebuffer, the appended insns instead
   of looping through the opcode tree.
   Possibly dump the jitted codebuffer as PLJC .plc files, to save
   next startup parse time.

   This must be done with jit macro trickery on the C level.

2. Use a self-written B<B::Asm> library to dump architectur specific
   asm insns directly.
   Either dump the jitted codebuffer as PLJC .plc files, or construct
   the necessary OS headers directly. For writing the PE/COFF format
   see e.g. my L<C::DynaLib> pl2exe or Audreys L<Win32::Exe>, for writing
   Elf see e.g. L<GNU libjit>.

   This could be done on a higher Perl level, and avoids the lightning
   macro abstraction.

=head1 OPTIMIZATIONS

On native code assembler level we would be able to optimize on levels which
cannot be done within our current opcode i.e. bytecode structure, which are not
inlined and must handle its argument on the stack.

* detect SV's with IVonly values in subblocks which will not be changed at
  run-time. All SV's and simple to optimize integer opcodes can be
  replaced by direct int instructions, if possible also in registers.

* same with string-only PV's, without any magic, being overloaded or tied.

So we would reduce stack handling for then unnecessary perl opcodes and
optimize on strict types, as with a good high-level type-aware compiler,
such as the CMUCL/SBCL "python" compiler.

=cut

BEGIN {
  push @INC, '.';
  require 'regen_lib.pl';
}
use strict;
use Config;
my %alias_to = (
    U32 => [qw(line_t)],
    PADOFFSET => [qw(STRLEN SSize_t)],
    U16 => [qw(OPCODE short)],
    U8  => [qw(char)],
);

my (%alias_from, $from, $tos);
while (($from, $tos) = each %alias_to) {
    map { $alias_from{$_} = $from } @$tos;
}

use B qw(@optype @specialsv_name);
use B::Asmdata qw(%insn_data @insn_name);

my $c_header = <<'EOT';
/* -*- buffer-read-only: t -*-
 *
 *      Copyright (c) 1996-1999 Malcolm Beattie
 *      Copyright (c) 2007 Yann Nicolas Dauphin (no code yet from clisp)
 *      Copyright (c) 2008 Reini Urban
 *
 *      You may distribute under the terms of either the GNU General Public
 *      License or the Artistic License, as specified in the README file.
 *
 */
/*
 * This file is autogenerated from jitcompiler.pl. Changes made here will be lost.
 */
EOT

safer_unlink "ByteLoader/jitrun.c", "ByteLoader/jitrun.h";

#
# Boilerplate for jitrun.c
#
open(JITRUN_C, ">ByteLoader/jitrun.c") or die "ByteLoader/jitrun.c: $!";
binmode JITRUN_C;
print JITRUN_C $c_header, <<'EOT';

#define PERL_NO_GET_CONTEXT
#include "EXTERN.h"
#include "perl.h"
#define NO_XSLOCKS
#include "XSUB.h"

#include <lightning/lightning.h>

#ifndef PL_tokenbuf /* Change 31252: move PL_tokenbuf into the PL_parser struct */
#define PL_tokenbuf		(PL_parser->tokenbuf)
#endif

#include "jitrun.h"
#include "byterun.h"
#include "bytecode.h"

static const int optype_size[] = {
EOT
my $i = 0;
for ($i = 0; $i < @optype - 1; $i++) {
    printf JITRUN_C "    sizeof(%s),\n", $optype[$i], $i;
}
printf JITRUN_C "    sizeof(%s)\n", $optype[$i], $i;
print JITRUN_C <<'EOT';
};

void *
jit_obj_store(pTHX_ struct byteloader_state *bstate, void *obj, I32 ix)
{
    if (ix > bstate->bs_obj_list_fill) {
	Renew(bstate->bs_obj_list, ix + 32, void*);
	bstate->bs_obj_list_fill = ix + 31;
    }
    bstate->bs_obj_list[ix] = obj;
    return obj;
}

int
jitrun(pTHX_ struct byteloader_state *bstate)
{
    register int insn;
    U32 isjit = 0;
    U32 ix;
    SV *specialsv_list[6];

    BYTECODE_HEADER_CHECK;	/* croak if incorrect platform,
    if (!isjit) {		   set isjit if PLJC magic header */
      Perl_croak(aTHX_ "No perl jitcode header PLJC\n");
      return 0;
    }

    Newx(bstate->bs_obj_list, 32, void*); /* set op objlist */
    bstate->bs_obj_list_fill = 31;
    bstate->bs_obj_list[0] = NULL; /* first is always Null */
    bstate->bs_ix = 1;

EOT

for my $i ( 0 .. $#specialsv_name ) {
    print JITRUN_C "    specialsv_list[$i] = $specialsv_name[$i];\n";
}

# TODO: Portably mmap the file and jump into it.
print JITRUN_C <<'EOT';

    Perl_croak(aTHX_ "TODO! jit_run the code\n"); /* jit_run the codebuffer */

EOT

#
# Finish off jitrun.c
#
print JITRUN_C <<'EOT';
    return 0;
}

/* ex: set ro: */
EOT

#
# TODO: Write some jmp targets and functions into jitrun.h
#
open(JITRUN_H, ">ByteLoader/jitrun.h") or die "ByteLoader/jitrun.h: $!";
binmode JITRUN_H;
print JITRUN_H $c_header, <<'EOT';
int jit_getc(struct byteloader_fdata *);
int jit_read(struct byteloader_fdata *, char *, size_t, size_t);
int jitrun(pTHX_ register struct byteloader_state *);
EOT

print JITRUN_H "/* ex: set ro: */\n";

close JITRUN_H or die "Error closing JITRUN_H: $!";
close JITRUN_C or die "Error closing JITRUN_C: $!";

__END__
