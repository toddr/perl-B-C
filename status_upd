#!/usr/bin/perl -w
# status_upd [-suqftad] [ 1.26 | path ]
# process perlall-maketest logfiles:
#  `perl$ver Makefile.PL && make test > log.test-$platform-$ver; make clean`
# and find and sort by FAIL/TODO and platform+version
#
# OPTIONS:
# -s sort by test
# -u update STATUS
# -q quiet
# -f fail only
# -t todo only
# -a do not skip too old logs
# -d no unify dumps
#
use strict;
use Data::Dumper;
use Set::Object qw(reftype);

my $logs = "log.test-*-5.*";
my $dir = ".";
my $STATUS = "./STATUS";

chdir ".." if ! -d "t" and -d "../t";
chdir "../.." if ! -d "t" and -d "../../t";
my ($sortbytest, $update, $quiet, $failonly, $todoonly, $noskip, $nodump);

for (@ARGV) {
  /^-s$/ and $sortbytest++;
  /^-u$/ and $update++;
  /^-q$/ and $quiet++;
  /^-f$/ and $failonly++;
  /^-t$/ and $todoonly++;
  /^-a$/ and $noskip++;
  /^-d$/ and $nodump++;
  -d "t/reports/$_" and $dir = "t/reports/$_";
  -d "$_" and $dir = $_;
}

# read stdout lines from a grep command and
# prints and return a string of the sorted
# results and a hash for further processing.
sub status {
  my @g = @_;
  my $s = "";
  my %h;
  my $prefix = '';
  my $oldprefix = '';
  while (@g) {
    if ($g[0] =~ /^--/) {
      $oldprefix = $prefix if $prefix;
      $prefix = '';
      shift @g;
      next;
    }
    my $file = shift @g;
    my $failed = shift @g;
    my $ctime = 0;
    unless ($prefix) {
      my ($f) = $file =~ m{(log.test-.*?)-t/};
      ($prefix) = $file =~ m{log.test-(.*?)-t/};
      if ($prefix and $oldprefix ne $prefix) {
	#$prefix =~ s/ATGRZ.+?-/cygwin-/;
        $ctime = -f $f ? sprintf("%0.3f", -C $f) : 0;
	$s .= "\n$prefix:\n";
	print STDERR "\n$prefix: age=$ctime" unless $quiet;
        if ($ctime > 1.5 and !$noskip) {
          print STDERR " skipped: too old" unless $quiet;
        }
        print STDERR "\n" unless $quiet;
      }
    }
    next unless $prefix;
    next unless $file;
    chomp $file;
    ($file) = $file =~ m{log.test-.*-(t/[\w\.]+\s?)};
    $file =~ s{\s*$}{};
    $file =~ s{^\s*}{};
    $failed =~ s{^.+(Failed tests?:?)}{$1}i;
    $failed =~ s{^.+TODO passed:}{TODO passed:};
    chomp $failed;
    $failed =~ s/(\d)-(\d)/$1..$2/g;
    my $f = $failed;
    $f =~ s{^Failed tests?:?\s*(.+)$}{$1}i;
    $f =~ s{^TODO passed:\s*}{};
    $f =~ s/ //g;
    my $c = "$file\t";
    $c .= "\t" if length($file) < 8;
    $c .= "$failed\n";
    $h{$prefix}->{$file} = $f;
    next if $ctime > 1.5 and !$noskip;
    print STDERR "$c" unless $quiet;
    $s .= $c;
  }
  print "\n";
  [ $s, \%h ];
}

# split into platform, version, [feature]
# debian-squeeze-amd64-5.10.1-nt => ("debian-squeeze-amd64", "5.10", "nt")
sub platform_version_split {
  local $_ = shift;
  my ($p,$v,$f) = m/^(.+)-(5\.[\d\.]+)([-dnt]+)?$/;
  $f =~ s/^-// if $f; # d, d-nt, nt or empty
  $v =~ s/(\d\.\d+)\.\d+/$1/;
  return ($p,$v,$f);
}

# From List::Util
# One argument is true
sub any { $_ && return 1 for @_; 0 }
# All arguments are true
sub all { $_ || return 0 for @_; 1 }
# All arguments are false
sub none { $_ && return 0 for @_; 1 }

sub cleanup_deleted {
  my $h = shift;
  my $f = shift;
  for my $p (keys %$h) { 		# cleanup undef ("deleted") results
    for (keys %{$h->{$p}}) {
      delete $f->{$_} unless defined $f->{$_};
    }
  }
  $f;
}

sub h_size($) { scalar keys %{$_[0]} }
sub split_tests($) {
  my $t = shift;
  #$t =~ s/Failed tests?:?\s*//;
  map {
    if (/(\d+)\.\.(\d+)/) {
      ($1 .. $2)
    } else {
      $_
    }
  } split /,\s*/, $t;
}

sub in_both ($$) {
  # only the elements on both lists
  my %h1 = map { $_ => 1 } @{$_[0]};
  my %h2 = map { $_ => 1 } @{$_[1]};
  for (keys %h1) {
    my $e = $h1{$_};
    undef $h1{$_} unless $h2{$e};
  }
  sort keys %h1;
}

# every
sub all_common {
  my $h = shift;		# platform_version -> test_file -> test_no_failed
  my $result = shift;		# skip already deleted results, initially empty
  my (%tests);
  # init with shortest list, sort hash by least number of keys
  my @p = sort { h_size($h->{$a}) <=> h_size($h->{$b}) } keys %$h;
  my $pivot = $p[0];
  my $pivotset = Set::Object->new(keys %{$h->{$pivot}});
  for ($pivotset->members) {
    my $k = $h->{$pivot}->{$_};
    $tests{$_} = Set::Object->new(split_tests($k));
  }
  for my $p (@_) {		# check for common keys (in every)
    my $c = $pivotset * Set::Object->new(keys %{$h->{$p}});
    for ($c->members) {
      if (exists $tests{$_}) {
        $result->{$_} = $tests{$_} * $result->{$_}; # without already
        $result->{$_} = $result->{$_} * Set::Object->new( split_tests($h->{$p}->{$_}) )
          if $result->{$_}->members;
        $result->{$_} = $result->{$_}->members;
      }
      delete $result->{$_} unless $result->{$_};
    }
  }
  return $result;
}

sub unify_results {
  my $h = shift; 	# platform_version -> file -> failed
  my $name = shift; 	# todo or fail
  # first check for common results in files, all platforms
  my @platforms = keys %$h;
  my $files = all_common($h, {}, @platforms);
  if (%$files) {
    print Data::Dumper->Dump([$files],["common_$name"]);

    # initialize for next round: delete already common found
    for my $p (@platforms) {
      for (keys %{$h->{$p}}) {
        if (!$files->{$_}) {
          undef $h->{$p}->{$_};
        } elsif ($files->{$_} ne $h->{$p}->{$_}) { # strip out not common tests
          my @t1 = split_tests $h->{$p}->{$_};
          my @t2 = split_tests $files->{$_};
          my @both = in_both(\@t1,\@t2);
          if (@both) {
            $h->{$p}->{$_} = join(",", @both);
          } else {
            undef $h->{$p}->{$_};
          }
        }
      }
    }
  }

  my $h_sav = $h;
  # ignore the platform for now. we don't have any platform issues.
  # check for all pairs version - feature the shortest commons
  # 1. sort by versions (ignore platform + features) *-v-*
  my %versions;
  for (@platforms) {
    my ($p,$v,$f) = platform_version_split($_);
    push @{$versions{$v}}, ($_);
  }
  for my $v (sort keys %versions) {
    my $v1 = all_common($h, $files, @{$versions{$v}});
    if (%$v1) {
      print Data::Dumper->Dump([$v1],["v$v $name"]);
    }
  }

  # 2. sort by feature (ignore platform + version) *-*-f
  $h = $h_sav;
  my %feat;
  for (@platforms) {
    my ($p,$v,$f) = platform_version_split($_);
    $f = "" unless $f;
    push @{$feat{$f}}, ($_);
  }
  for my $f (sort keys %feat) {
    my $f1 = all_common($h, $files, @{$feat{$f}});
    if (%$f1) {
      print Data::Dumper->Dump([$f1],["feature $f $name"]);
    }
  }
}

my $dlogs = $dir eq '.' ? "$logs" : "$dir/$logs";
if (!$todoonly) {
  my $cmd = 'grep -a -B1 -i "Failed test" ' . $dlogs;
  print STDERR "$cmd\n" unless $quiet;
  my @g = `$cmd` or die $@;

  my $failed = status(@g);
  my $failedu = unify_results($failed->[1], "fail") unless $nodump;
}

if (!$failonly) {
  my $cmd = 'grep -a -B1 -i "TODO passed" ' . $dlogs;
  print STDERR "\n$cmd\n" unless $quiet;
  my @g = `$cmd` or die $@;

  my $todo = status(@g);
  my $todou = unify_results($todo->[1], "todo_pass") unless $nodump;
}
# XXX TODO: update the TEST STATUS section in "./STATUS"
if ($update) {
  die "file not found $STATUS\n" unless -e $STATUS;
  die "-u update STATUS not yet implemented\n";
  # sort away platforms
}

# Local Variables:
#   mode: cperl
#   cperl-indent-level: 2
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=2:
